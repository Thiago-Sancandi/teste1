<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<title>Labirinto 3D - Terceira Pessoa</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>
<script>
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Luz
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(10,20,10);
  scene.add(dirLight);

  // Chão
  const floorGeometry = new THREE.PlaneGeometry(200, 200);
  const floorMaterial = new THREE.MeshStandardMaterial({color: 0x333333});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Paredes do labirinto simples
  const wallGeometry = new THREE.BoxGeometry(10, 20, 2);
  const wallMaterial = new THREE.MeshStandardMaterial({color: 0x888888});
  const walls = [];

  // Criar 4 paredes formando um corredor básico
  const positions = [
    {x:0, y:10, z:-25, sx:20, sz:2},  // parede frontal
    {x:0, y:10, z:25, sx:20, sz:2},   // parede traseira
    {x:-10, y:10, z:0, sx:2, sz:50},  // parede esquerda
    {x:10, y:10, z:0, sx:2, sz:50}    // parede direita
  ];

  positions.forEach(pos => {
    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
    wall.position.set(pos.x, pos.y, pos.z);
    wall.scale.set(pos.sx/10, 1, pos.sz/2);
    scene.add(wall);
    walls.push(wall);
  });

  // Jogador (representado por uma caixa)
  const playerGeometry = new THREE.BoxGeometry(4, 8, 4);
  const playerMaterial = new THREE.MeshStandardMaterial({color: 0x00ff00});
  const player = new THREE.Mesh(playerGeometry, playerMaterial);
  player.position.set(0, 4, 20);
  scene.add(player);

  // Câmera terceira pessoa: atrás e acima do jogador
  const cameraOffset = new THREE.Vector3(0, 15, -25);

  // Controle básico de movimento
  const moveSpeed = 0.5;
  const keysPressed = {};

  window.addEventListener('keydown', e => { keysPressed[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', e => { keysPressed[e.key.toLowerCase()] = false; });

  // Função para detectar colisão simples (AABB)
  function checkCollision(box1, box2) {
    return (Math.abs(box1.x - box2.x) * 2 < (box1.width + box2.width)) &&
           (Math.abs(box1.y - box2.y) * 2 < (box1.height + box2.height)) &&
           (Math.abs(box1.z - box2.z) * 2 < (box1.depth + box2.depth));
  }

  function getBox(mesh) {
    const pos = mesh.position;
    const scale = mesh.scale;
    const geometry = mesh.geometry.parameters;
    return {
      x: pos.x,
      y: pos.y,
      z: pos.z,
      width: (geometry.width || 1) * scale.x,
      height: (geometry.height || 1) * scale.y,
      depth: (geometry.depth || 1) * scale.z
    };
  }

  // Atualiza posição do jogador e trata colisões
  function movePlayer() {
    let direction = new THREE.Vector3();

    if (keysPressed['arrowup']) direction.z -= moveSpeed;
    if (keysPressed['arrowdown']) direction.z += moveSpeed;
    if (keysPressed['arrowleft']) direction.x -= moveSpeed;
    if (keysPressed['arrowright']) direction.x += moveSpeed;

    if (direction.length() === 0) return;

    const newPos = player.position.clone().add(direction);

    // Criar caixa do jogador com nova posição
    const playerBox = {
      x: newPos.x,
      y: player.position.y,
      z: newPos.z,
      width: 4,
      height: 8,
      depth: 4
    };

    // Verificar colisão com todas as paredes
    for (let wall of walls) {
      const wallBox = getBox(wall);
      if (checkCollision(playerBox, wallBox)) {
        // Colidiu, não move
        return;
      }
    }

    // Sem colisão, move o jogador
    player.position.copy(newPos);
  }

  function animate() {
    requestAnimationFrame(animate);

    movePlayer();

    // Atualiza câmera na posição terceira pessoa atrás do jogador
    const camPos = player.position.clone().add(cameraOffset);
    camera.position.lerp(camPos, 0.1);
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  animate();

  // Ajustar ao redimensionar janela
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
